CSCE 3110.501  Project:Team 1 <br>
Haley Kang (hjk0056)<br>
Mario Onofrio<br>
Marcus Lara Sanchez

In this Project we are tasked with designing and proving a solution to the following questions:
1. I am in city “A”, can I fly to city  “B”  with less than x connections? Give me the 
   route with the smallest number of connections or tell me there is no such a route. 

2. Give me the route with the smallest number of connections from city “A” to city 
   “D” through city “B” and “C”. (the order of  “B” and “C” is not important). Or 
   tell me there is no such a route 

3. I want to start from city “A”, visit all the cities that can be reached and then come 
   back to “A” using as less connections as possible. Give me a route or tell me there 
   is no such a route. (note: once you come back to “A”, you do not go out 
   anymore). 

4. I am in city “A”, my friend John is in a different city “B”, and my other friend 
   Ann is in yet another different city “C”. We want to find a city different from the 
   three cities we are in to meet so that the total number of connections among three 
   of us is minimized. Tell me the city we should fly to and the routes for us or tell 
   me there is no such a city. 


Compile/Run:
1. Navigate to directory.
2. Make sure the input text file is within the directory and is called "flight.txt" since this 
   is hardcoded into our program.
3. To compile type:<br>
   g++ main.cpp

4. To run compiled program type:<br>
   ./a.out

Note:
   If using a cell machine, the climit library must be included. This was one of the problems
   we had to fix, and it is included into the code. This code was built and tested mainly on a
   windows operating system through vs code.
   
   If the file name is different, refer to the main function and change the filename variable 
   to match the file. 
   
   If there may be any possible issues coming from the graph, press option 5 to print it out. 
   This graph (if generated) will be useful to ensure that input is correct as it is case 
   sensitive.
      If no graph is generated, then there is an issue with the input file.
      
   The program is hardcoded to the format of the "flight.txt" file and will only work in the
   specific layout generated by the graph data generator provided (graphGen.cpp).


Overview:
Creating the Graph:
    To create our graph we created a function. It takes in the filename that is in the same 
    directory and then begins to parse through it. It parses and creates the paths by looking at
    'From:' and 'To:' as key words. One issue that occured when parsing through the flight paths
    was not reading the node included in the same line as 'From:' or 'To:'. In order to prevent 
    any issues it would be best to keep a city right after these ase we found a work around to it. 
    Once the graph is created we can then use it to search for our airline routes. This graph can 
    also be printed as implemented by the printGraph feature that prints the graph back into a 
    readable format. This was particularly useful in providing test input and debugging as we came 
    to learn how case sensitive the input can be.

Building the main function and UI:
    We wanted to create a straight to the point UI. To do this we implemented a simple switch case 
    in our main functoin and requested input where needed depending on which task was asked to 
    complete. As an extra option we included option 5 for us when debugging. Considering how the 
    testing was not just going to consists of one flight.txt file we decided to keep it in order 
    to make it easier for the user to input their own flight.txt file. Depending on the selection 
    of 1-4 it answered a different question that we were tasked. 

Solution to Question 1:
    In question 1 we were asked if it was possible to fly between two cities with less than x 
    connections between them. To do this we received input asking the two desired cities and the 
    maximum amount of connections. After this we sent it to a function to find if it was possible 
    to do this under x amount of connections. This function is called findShortestRoute and accepts 
    these 3 parameters. Using our variable distance and a stack, path, we can keep a counter of the 
    amount of connections to ensure it is less than x connections. This same stack is not just used 
    to count, but for popping and printing our cities to provide us a route less than or equal to x 
    connections. 

Solution to Question 2:
    Our next tasks is to provide a route that goes from A-Z that goes through cities, 'H' and 'I'.
    It doesnt matter what order it is so long as H and I are on route to Z from A. To achieve this
    first we must check if A-Z is even possible. If it is then we need to find a path that contains
    our two desired cities. To do this we used a queue and logic with the stack similar to question
    1 to print out the path. To find the actual path however, we keep track of wether or not we have
    seen city 1 and 2 in our path. This path is stored as a string variable. We keep perfmoring bfs
    until we find a path that goes through both required cities.

Solution to Question 3:
    The third task requires us to find as many nodes as we can visit in a single path and return
    back our starting position only once. For this one we did some research and came across the
    Hamiltonian Cycle which utilizes dfs. To achieve this we needed to check if it was safe to travel.
    Using recursive backtracking it treis to build a path visiting all other cities while checking if
    an edge from the last city can go back to the first initial starting point. 

Solution to Question 4:
    Our last task involves finding the best city(if possible) for 3 people to meetup in.
    These routes should be the ones with the least amount of connections or distance travelled.
    In order to ensure that we would find the best path we needeed a way to check the paths for
    each starting point. To do this we implemented the bfs algorithm. From here we used this on
    each starting point and compared the nodes travelled to to other paths to ensure that we were
    getting the minumum path similar to the logic in question 1. It takes 4 parameters being the
    city inputs and the graph to navigate through. By comparing the different paths and connections
    for each city we can find the best city for all 3 friends to meet at using bfs.
